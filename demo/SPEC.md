# Spec-Editor Demo - Implementation Spec

## Purpose
Demonstrate a simple Flask UI for managing customer infrastructure pods via GitHub workflow_dispatch. Addresses three customer pain points:
1. **Instance naming chaos** - "host1" → "advworks-dev-web1"
2. **Manual workflow inputs** - Pre-populated form vs typing 15 fields
3. **Unwanted traffic to app servers** - Demonstrates adding WAF to ALBs

## Terminology
- **spec-editor**: Python/Flask app with form to trigger deployments
- **Pod**: Customer infrastructure (EC2 + ALB + optional WAF)
- **spec.yml**: YAML file defining pod configuration

---

## Flow

```
User opens spec-editor
  ↓
Select customer + environment (e.g., advworks/dev)
  ↓
Flask fetches spec.yml from GitHub, parses it
  ↓
Form renders with current values pre-populated
  ↓
User edits fields (instance name, WAF toggle)
  ↓
Flask validates inputs
  ↓
Flask calls workflow_dispatch with form data
  ↓
Customer's existing GitHub workflow runs
  ├─ Receives inputs
  ├─ Renders spec.yml from inputs
  ├─ Runs terraform apply
  └─ Commits spec.yml on success
  ↓
Flask shows: "Deployed! [link to action run]"
```

---

## MVP Form Fields

**Read-only context** (from URL/selection):
- Customer: `advworks`, `northwind`, `contoso`
- Environment: `dev`, `stg`, `prd`

**Editable fields**:
- **Instance Name**: text input (e.g., `web1`, `app1`)
  - Terraform renders as: `{customer}-{env}-{name}` → `advworks-dev-web1`
- **WAF Enabled**: checkbox (true/false)
  - Controls WAF attachment to ALB

**Generated by Terraform**:
- Full instance Name tag: `{customer}-{env}-{instance_name}`
- Common tags: `Customer`, `Environment`, `ManagedBy: Terraform`

---

## Components

### Backend
- **app.py**: Flask app
  - Route: `/` - List pods, select customer/env
  - Route: `/edit/{customer}/{env}` - Fetch spec, render form
  - Route: `/deploy` - Validate, trigger workflow_dispatch
- **templates/form.html.j2**: Jinja form template
- **requirements.txt**: `flask`, `PyGithub`, `pyyaml`
- **Dockerfile**: Based on `python:3.12-slim`

### Infrastructure
```
demo/infra/
  advworks/
    dev/spec.yml
    stg/spec.yml
    prd/spec.yml
  northwind/
    dev/spec.yml
    prd/spec.yml
  contoso/
    dev/spec.yml
```

### Terraform Modules
```
demo/tfmodules/
  main.tf         # Reads spec.yml via yamldecode
  ec2.tf          # EC2 instance with Name tag
  alb.tf          # ALB with optional WAF
  waf.tf          # Conditional WAF (count = var.waf_enabled ? 1 : 0)
  variables.tf
  provider.tf
```

### GitHub Actions
```
.github/workflows/deploy-pod.yml
  on:
    workflow_dispatch:
      inputs:
        customer: (string, required)
        environment: (string, required)
        instance_name: (string, required)
        waf_enabled: (boolean, default false)
```

### Demo Scripts
- **scripts/test-waf.sh**: Curl script to demonstrate WAF blocking

---

## spec.yml Schema (Simplified)

```yaml
apiVersion: v1
kind: Pod
metadata:
  customer: advworks
  environment: dev
spec:
  compute:
    instance_name: web1          # User-friendly name
    instance_type: t3.micro
  security:
    waf:
      enabled: false
  tags:
    owner: ops-team
    project: customer-portal
```

**Terraform reads this and generates**:
- EC2 Name tag: `advworks-dev-web1`
- WAF attachment: conditional on `spec.security.waf.enabled`

---

## Deployment Architecture

```
┌─────────────────┐
│  spec-editor    │ Flask on EC2 (docker-compose)
│  (Flask app)    │
└────────┬────────┘
         │
         ├─ GET: Fetch spec.yml from GitHub
         ├─ POST: Trigger workflow_dispatch
         └─ Show: Action run URL
              ↓
┌─────────────────────────────────┐
│  GitHub Actions                 │
│  deploy-pod.yml                 │
│  (Customer's existing workflow) │
└────────┬────────────────────────┘
         │
         ├─ Render spec.yml from inputs
         ├─ Terraform apply
         │   ├─ EC2: advworks-dev-web1
         │   ├─ ALB: advworks-dev-alb
         │   └─ WAF: (if enabled)
         └─ Commit spec.yml
```

---

## Docker Deployment

**docker-compose.yml**:
```yaml
services:
  spec-editor:
    image: ghcr.io/trakrf/spec-editor:latest
    ports:
      - "80:5000"
    environment:
      - GITHUB_TOKEN=${GITHUB_TOKEN}
      - GITHUB_REPO=trakrf/action-spec
      - SPECS_PATH=demo/infra
    restart: unless-stopped

  demo-app:
    image: hashicorp/http-echo
    command: ["-text=Demo App Running"]
    ports:
      - "8080:5353"
```

**Deployment**:
```bash
# On EC2 t4g.nano (via Ansible + Docker CE + Portainer)
docker-compose up -d
```

---

## Demo Script (5 minutes)

1. **Show current pain**: GitHub UI with manual workflow_dispatch inputs
2. **Open spec-editor**: Shows advworks/dev pod
3. **Form pre-populated**: Instance name: `web1`, WAF: unchecked
4. **Current state**: AWS Console shows "host1" (old tooling)
5. **Change name**: `web1` → `app1`
6. **Enable WAF**: Check the box
7. **Submit**: Flask shows "Deployed! [action link]"
8. **Watch action**: Terraform apply runs
9. **Verify AWS**: Console now shows `advworks-dev-app1` ✅
10. **Test WAF**: Run `scripts/test-waf.sh` → see blocks ✅

**Customer reaction**: "Oh wow, it fixed both problems at once."

---

## MVP Scope (What We Build)

### In Scope ✅
- Flask app with pod selection + form
- PyGithub integration (fetch spec, trigger workflow)
- Terraform modules (EC2 + ALB + WAF)
- Instance naming convention (`{customer}-{env}-{name}`)
- WAF toggle (enable/disable)
- Docker packaging (Dockerfile + compose)
- GitHub Action (workflow_dispatch handler)
- Demo script (curl for WAF test)

### Out of Scope (Extra Credit)
- [ ] boto3/AWS discovery (pre-populate from live state)
- [ ] GitOps PR flow (branch + PR + merge)
- [ ] Locust load testing (curl script is sufficient)
- [ ] Route53 A records (use ALB DNS for demo)
- [ ] EC2 root volume resize
- [ ] Windows instances (customer is Windows shop, but Linux for demo)
- [ ] ASG with min/max instances
- [ ] Multiple instance types in dropdown
- [ ] Spec validation beyond basic schema
- [ ] Real-time action status polling

---

## Success Criteria

**Working demo when**:
- [ ] spec-editor loads on EC2
- [ ] Shows 9 pods (3 customers × 3 envs) - created in Phase D7
- [ ] Form loads advworks/dev spec from GitHub
- [ ] Submit triggers workflow_dispatch successfully
- [ ] Workflow runs terraform apply
- [ ] AWS shows EC2 with new name: `advworks-dev-web1`
- [ ] WAF toggle creates/destroys WAF
- [ ] Curl script demonstrates blocking
- [ ] Pattern scales (all 9 pods work identically)

**Customer sees value**:
- ✅ Fixes naming problem (host1 → advworks-dev-web1)
- ✅ Simplifies workflow (form vs manual inputs)
- ✅ Adds WAF protection with one checkbox
- ✅ Works with existing tooling (no workflow changes)
- ✅ Multi-tenant ready (3 customers shown)

---

## File Structure

```
demo/
  SPEC.md                      # This document

  backend/
    app.py                     # Flask application
    templates/
      index.html.j2            # Pod selection page
      form.html.j2             # Spec editor form
    requirements.txt
    Dockerfile

  docker-compose.yml           # Flask + demo app

  infra/
    advworks/
      dev/
        main.tf                # Calls tfmodules/pod
        spec.yml               # Pod configuration
        backend.tf             # S3 backend config
      stg/
        main.tf
        spec.yml
        backend.tf
      prd/
        main.tf
        spec.yml
        backend.tf
    northwind/
      dev/
        main.tf
        spec.yml
        backend.tf
      prd/
        main.tf
        spec.yml
        backend.tf
    contoso/
      dev/
        main.tf
        spec.yml
        backend.tf

  tfmodules/
    pod/                       # Reusable pod module
      main.tf                  # Module orchestration
      ec2.tf                   # EC2 with naming convention
      alb.tf                   # ALB
      waf.tf                   # Optional WAF
      variables.tf             # Module inputs
      outputs.tf               # Module outputs
      data.tf                  # Data sources (AMI lookup, etc)

  scripts/
    test-waf.sh                # Curl script for demo

  .github/workflows/
    build-spec-editor.yml      # Build Docker image
    deploy-pod.yml             # Workflow dispatch handler
```

---

## Work Breakdown Structure (PR-Sized Phases)

### Phase D1: Foundation - Specs & Basic Terraform
**Effort**: 1-2 hours
**Goal**: Establish data contracts and basic infrastructure module

**Deliverables**:
- Create **ONE** spec.yml file (`advworks/dev` only - others in Phase D7)
- Create `demo/tfmodules/pod/` module structure
- EC2 module with naming convention tags only (no ALB, no WAF yet)
- Implementation `main.tf` in `advworks/dev/` that calls `../../../tfmodules/pod`
- User data script to run http-echo on boot via Docker
- Backend configuration for S3 state storage

**Note**: Starting with single pod to prove pattern, will scale to 9 pods in Phase D7

**spec.yml structure**:
```yaml
apiVersion: v1
kind: Pod
metadata:
  customer: advworks
  environment: dev
spec:
  compute:
    instance_name: web1
    instance_type: t4g.nano
  security:
    waf:
      enabled: false
```

**Module structure**:
```hcl
# demo/infra/advworks/dev/main.tf (implementation)
locals {
  spec = yamldecode(file("${path.module}/spec.yml"))
}

module "pod" {
  source = "../../../tfmodules/pod"

  customer      = local.spec.metadata.customer
  environment   = local.spec.metadata.environment
  instance_name = local.spec.spec.compute.instance_name
  instance_type = local.spec.spec.compute.instance_type
  waf_enabled   = local.spec.spec.security.waf.enabled
}

output "instance_id" {
  value = module.pod.instance_id
}
```

```hcl
# demo/tfmodules/pod/ec2.tf (module)
resource "aws_instance" "pod" {
  ami           = data.aws_ami.ubuntu.id
  instance_type = var.instance_type

  user_data = <<-EOF
    #!/bin/bash
    # Install Docker
    curl -fsSL https://get.docker.com -o get-docker.sh
    sh get-docker.sh

    # Run http-echo on boot (uses mendhak/http-https-echo to show request details)
    docker run -d \
      --name demo-app \
      --restart unless-stopped \
      -p 80:8080 \
      mendhak/http-https-echo:latest
    EOF

  tags = {
    Name        = "${var.customer}-${var.environment}-${var.instance_name}"
    Customer    = var.customer
    Environment = var.environment
    ManagedBy   = "Terraform"
  }
}
```

**Test Criteria**:
```bash
cd demo/infra/advworks/dev
terraform init
terraform plan
# Should show EC2 with Name tag: "advworks-dev-web1"
# Module source: "../../../tfmodules/pod"

terraform apply -auto-approve

# Wait ~2 minutes for user_data to complete
sleep 120

# Get instance IP
INSTANCE_IP=$(aws ec2 describe-instances \
  --filters "Name=tag:Name,Values=advworks-dev-web1" \
  --query 'Reservations[0].Instances[0].PublicIpAddress' \
  --output text)

# Test http-echo is running
curl http://$INSTANCE_IP/
# Should return: "Hello from AdventureWorks Development"
```

**Acceptance**:
- ✅ Can manually deploy EC2 with correct naming from spec.yml
- ✅ Module structure works (implementation calls tfmodules/pod)
- ✅ Instance is immediately touchable via HTTP after ~2 min

---

### Phase D2: Add ALB + Conditional WAF
**Effort**: 1-2 hours
**Goal**: Complete infrastructure modules with WAF toggle

**Deliverables**:
- ALB module (target group, listener, security groups)
- WAF module with conditional creation (`count = var.waf_enabled ? 1 : 0`)
- WAF association to ALB when enabled
- Update all spec.yml files with WAF configuration

**Test Criteria**:
```bash
# Test with WAF disabled
terraform apply -var="waf_enabled=false"
# Should create EC2 + ALB, no WAF

# Test with WAF enabled
terraform apply -var="waf_enabled=true"
# Should create EC2 + ALB + WAF + association
```

**Acceptance**: Can toggle WAF on/off via Terraform variable

---

### Phase D3: GitHub Action - Workflow Dispatch
**Effort**: 1-2 hours
**Goal**: Automate deployment via GitHub Actions

**Deliverables**:
- `.github/workflows/deploy-pod.yml`
- workflow_dispatch inputs: `customer`, `environment`, `instance_name`, `waf_enabled`
- Workflow renders spec.yml from inputs (or reads existing spec)
- Workflow runs terraform plan/apply for specified pod
- Workflow commits updated spec.yml back to repo (optional for MVP)

**Test Criteria**:
```bash
# Manual trigger from GitHub UI:
# 1. Go to Actions tab
# 2. Select "Deploy Pod"
# 3. Click "Run workflow"
# 4. Fill inputs: advworks, dev, app1, true
# 5. Watch workflow run terraform apply
# 6. Check AWS: EC2 named "advworks-dev-app1" with WAF enabled
```

**Acceptance**: Can deploy infrastructure from GitHub UI using workflow_dispatch

---

### Phase D4: Flask App - Read Operations
**Effort**: 2-3 hours
**Goal**: Build UI to view specs (no editing yet)

**Deliverables**:
- `demo/backend/app.py` with Flask skeleton
- Route: `GET /` - List all pods (discover via GitHub API)
- Route: `GET /pod/<customer>/<env>` - Show spec in form (read-only initially)
- `templates/index.html.j2` - Pod listing page
- `templates/form.html.j2` - Spec viewer form
- PyGithub integration to fetch spec.yml files
- `requirements.txt` with dependencies

**Test Criteria**:
```bash
cd demo/backend
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt
export GITHUB_TOKEN=...
flask run

# Open http://localhost:5000
# Should see list of 9 pods
# Click advworks/dev
# Should see form with current values from GitHub
```

**Acceptance**: Can view all pods and see pre-populated forms from GitHub specs

---

### Phase D5: Flask App - Write Operations
**Effort**: 1-2 hours
**Goal**: Enable form submission and workflow triggering

**Deliverables**:
- Route: `POST /deploy` - Handle form submission
- Form validation (basic: required fields, valid values)
- PyGithub integration to trigger workflow_dispatch
- Display workflow run URL after submission
- Error handling with flash messages

**Test Criteria**:
```bash
# Run Flask app locally
# Open advworks/dev form
# Change instance_name: web1 → app1
# Toggle WAF: false → true
# Click "Deploy"
# Should show: "Deployed! View run: https://github.com/.../actions/runs/..."
# Check GitHub: workflow running with correct inputs
# Check AWS: Infrastructure updated
```

**Acceptance**: Form submission triggers GitHub Action and updates infrastructure

---

### Phase D6: Docker Packaging & Deployment
**Effort**: 1-2 hours
**Goal**: Containerize app and deploy to EC2

**Deliverables**:
- `demo/backend/Dockerfile` (based on python:3.12-slim)
- `demo/docker-compose.yml` (spec-editor + demo app)
- GitHub Action: `.github/workflows/build-spec-editor.yml`
- Build and push to ghcr.io
- Deployment documentation

**Test Criteria**:
```bash
# Local test
cd demo
docker-compose build
docker-compose up -d
curl http://localhost:5000/health
# Should return 200

# EC2 deployment (via Ansible + Portainer)
# Ansible playbook installs Docker CE
# Deploy docker-compose.yml
# Access http://ec2-public-ip/
# Should see spec-editor UI
```

**Acceptance**: spec-editor running in Docker on EC2, accessible via browser

---

### Phase D7: Integration Testing & Scale to 9 Pods
**Effort**: 1-2 hours
**Goal**: End-to-end testing, scale to full multi-tenant demo, and demo preparation

**Deliverables**:
- **Scale infrastructure**: Create remaining 8 pods using copy/paste pattern
  - `advworks/stg`, `advworks/prd`
  - `northwind/dev`, `northwind/prd`
  - `contoso/dev`
  - Vary spec.yml values (different instance names, demo messages, WAF states)
- `demo/scripts/test-waf.sh` - Curl script to test WAF blocking
  - Normal requests (should pass)
  - Scanner patterns (should block: /.env, /admin)
  - Rate limit test (should block after threshold)
- End-to-end test procedure document
- Demo walkthrough script
- Troubleshooting guide

**Scaling process** (get reps on the tooling):
```bash
# Copy pattern for each new pod
cp -r demo/infra/advworks/dev demo/infra/advworks/stg
cd demo/infra/advworks/stg

# Edit spec.yml
vim spec.yml
# Change: environment: dev → stg
# Maybe enable WAF for variety

# Test each pod
terraform init
terraform plan
# Verify it works

# Repeat for all 9 pods - builds muscle memory
```

**Test Criteria**:
```bash
# Full end-to-end test:
# 1. Open spec-editor on EC2
# 2. Should see 9 pods listed (3 customers × 3 envs)
# 3. Select advworks/dev
# 4. Enable WAF
# 5. Submit → watch action
# 6. Run test-waf.sh against advworks/dev ALB
# 7. Should see WAF blocks in output

# Test another pod (northwind/prd) to verify multi-tenant
# Verify all success criteria from spec
```

**Acceptance**:
- ✅ All 9 pods deployed and accessible
- ✅ spec-editor lists all pods
- ✅ Complete demo works end-to-end
- ✅ WAF blocking demonstrated
- ✅ Pattern proven reusable (created 8 pods by copying)

---

## Phase Dependencies

```
D1 (Specs + TF EC2)
  ↓
D2 (ALB + WAF)
  ↓
D3 (GitHub Action) ←─────┐
  ↓                       │
D4 (Flask Read) ──────────┘ (can develop in parallel)
  ↓
D5 (Flask Write - needs D3 to test)
  ↓
D6 (Docker)
  ↓
D7 (Integration)
```

**Total Estimated Time**: 8-12 hours for all phases

---

## Testing Strategy

**Per-Phase Testing**:
- Each phase has explicit test criteria
- Must pass tests before moving to next phase
- Manual testing acceptable for MVP

**Integration Testing** (Phase D7):
- Full end-to-end flow
- Multiple pods tested
- WAF toggle verified
- Edge cases handled

**Demo Rehearsal**:
- Practice walkthrough with timer
- Identify failure points
- Prepare backup scenarios

---

## Questions Resolved

- ✅ boto3: Not in MVP (follow-on)
- ✅ Multiple customers: YES (advworks, northwind, contoso)
- ✅ Multiple envs: YES (dev, stg, prd)
- ✅ Deployment flow: workflow_dispatch (Option A+)
- ✅ Structure: Separate `/demo` folder
- ✅ Pod discovery: GitHub API equivalent of `find`
- ✅ Form fields: Instance name + WAF toggle (start minimal)
- ✅ Post-submit UX: Show action run link
- ✅ Instance naming: Trivial (Name tag with convention)

---

## Out of Scope / Technical Debt

**Phase D1 Implementation Note**:
- ✅ **Completed**: Phase D1 infrastructure pattern proven with us-east-2 region
- ⚠️ **Tech Debt**: Originally planned for us-west-2 (Oregon), but that region has no VPCs in this AWS account
- 📋 **Future**: Migrate from us-east-2 (Ohio) to us-west-2 (Oregon) once VPC infrastructure is established
  - Update default region in `demo/tfmodules/pod/variables.tf`
  - Update default region in `demo/infra/advworks/dev/variables.tf`
  - Re-run terraform plan/apply in target region
  - Destroy old resources in us-east-2

**Rationale for Deferral**:
- Oregon (us-west-2) is geographically preferred for West Coast deployments
- However, proving the pattern and shipping Phase D1 took priority over VPC setup
- The module is region-agnostic, so migration is straightforward when ready

---

**Ready to build.**
